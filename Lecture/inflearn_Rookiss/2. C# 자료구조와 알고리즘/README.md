# 2. C# 자료구조와 알고리즘

복습하거나 새로운 학습 내용만 적었습니다.

### 개요

자료구조와 알고리즘 학습을 통해 길찾기 알고리즘을 구현하고 실제 게임에서도 길찾기 능력을 갖는 알고리즘을 구현하는 것이 목표인 강의입니다.

![image](https://cdn.inflearn.com/public/files/courses/324727/2d8d5911-b35c-485e-a245-ac242149c9ac/rookiss-pt2-2.gif)

---

## 미로 초기 맵 생성

![초기 맵생성](https://user-images.githubusercontent.com/67315288/119766376-dda56f80-beef-11eb-9da6-42c1bdbb27d2.png)

테두리를 모두 벽으로 막고 홀수 좌표만 빈공간을 만든다.  
이후에 미로 생성 알고리즘에서 짝수 좌표의 처리는 하지않고 홀수번째의 좌표만 연산하여 미로를 생산한다.

### BinaryTreeAlgorithm

![이진트리알고리즘](https://user-images.githubusercontent.com/67315288/119761091-2a844880-bee6-11eb-8936-2e0df2e624fe.png)

이진트리를 활용한 미로 만들기이다.  
점 하나를 트리의 노드로 가정하였을때 랜덤한 확률로 x좌표나 y좌표로 1씩 증가한 노드로 접근하여 벽 혹은 뚫린 공간으로 만든다.

![이진트리](https://user-images.githubusercontent.com/67315288/119761651-286eb980-bee7-11eb-990f-b91f7e3e0b56.png)

하지만 약간은 단조로운 패턴이 될 수 있다는 단점이 있다.

### SideWinderAlgorithm

![사이드와인더 알고리즘](https://user-images.githubusercontent.com/67315288/119765675-a5516180-beee-11eb-91bf-ca08c1a38225.png)

SideWinderAlgorithm을 통한 미로 만들기이다.
각 칸마다 x좌표 혹은 y좌표로 랜덤으로 선택하여 진행하는데 x좌표로 진행하게 되면 count 갯수를 세며 진행하고 만약 다음 진행시 y좌표 진행이 나온다면 여태까지 x좌표로 진행해왔던 노드중 하나를 선택하여 y방향으로 진행시킨다.

이진트리를 활용한 알고리즘보다 다채로운 패턴을 보여준다.

### 오른손 법칙

![Animation1](https://user-images.githubusercontent.com/67315288/119799582-291f4400-bf17-11eb-8467-1703676e16e9.gif)

미로찾기 알고리즘 중 하나인 우수법을 사용해 미로를 찾는다.

## 그래프

![그래프](https://user-images.githubusercontent.com/67315288/119821139-2fb8b600-bf2d-11eb-8925-484119ebe0ce.png)

길 찾기 알고리즘을 구현하기 위한 자료구조인 그래프

### DFS 깊이 우선 탐색

DFS를 구현 하기위해 행렬 또는 리스트를 통해 그래프를 구현하고 탐색한다.  
깊이 우선 탐색은 진행 방향으로 계속 탐색을 한다. 그리고 더이상 진행 할 수 없으면 빠져나와 탐색하지 않은곳으로 탐색을 다시 시작한다.

위 그림에서 DFS를 실행하여 0번에서 출발을 하면 0,1,2,3,4,5 순서로 탐색을 한다.

### BFS 너비 우선 탐색

너비 우선 탐색은 현재 노드에서 갈 수 있는 모든 노드를 먼저 큐에 넣는다.  
그리고 더 이상 진행할 수 없으면 큐에서 다음 순회할 노드를 가져온다. 이 과정을 반복해서 진행한다.

DFS와 다른 점은 BFS는 순회 과정에서 정보를 저장할 수 있다는 장점이 있다. 부모 노드의 정보나 현재 노드까지의 거리 Distance ( 또는 Depth )가 얼마나 되는지 파악할 수 있다.

BFS는 가중치가 없을때만 사용이 가능하다.

### 다익스트라 최단 경로 알고리즘

가중치가 있는 그래프에서 최단 경로를 찾을때 사용한다.  
하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다. ( 최단 거리보다 현재의 구한 거리정보가 더 짧으면 갱신 )

다만 최소 비용을 단순히 선형 탐색으로 찾기 때문에 자료의 수가 많다면 시간 복잡도가 O(N^2)가 된다.

## 트리

### 기본 개요

계층적 구조를 갖는 데이터를 표현하기 위한 비선형 구조의 자료구조  
선형구조와 비선형구조의 차이점은 선형자료는 자료를 저장하고 꺼내는 것에 초점이 맞춰져있고, 비선형구조는 표현에 초점이 맞춰져 있다.

### 이진 검색 트리

![이진 검색 트리](https://user-images.githubusercontent.com/67315288/120062701-711ca300-c09e-11eb-9b73-92d521dfd596.png)

왼쪽을 타고 가면 현재 값보다 작다
오른쪽을 타고 가면 현재 값보다 크다

값을 추가할때 단순히 추가하기만 하면 한쪽으로 기울어져서 균형이 깨진다.  
그렇게 된다면 결국 한쪽으로 무한하게 자료가 있으면 이진 검색 트리의 이점을 가질 수 없게된다.
그땐 트리 재배치를 통해 균형을 유지해야 한다. ( AVL, Red-Black )

### 힙 트리

![힙트리](https://user-images.githubusercontent.com/67315288/120062776-cc4e9580-c09e-11eb-98d5-8f5c28f88f9f.png)

특징 1 : 부모 노드가 가진 값은 항상 자식 노드가 가진 값보다 큰 트리이다.  
이전 이진 검색 트리에서 가졌던 균형이 깨진다는 한계점을 힙 트리에서는 이런식으로 해결한다.

1. 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있다
2. 마지막 레벨에 노드가 있을 때는, 항상 왼쪽부터 순서대로 채워야 한다.

특징 2: 노드 개수를 알면, 트리 구조는 무조건 확정할 수 있다.

따라서 배열을 이용해서 힙 구조를 바로 표현할 수 있다.

1. i번 노드의 왼쪽 자식은 \[(2\*i)+1] 번
1. i번 노드의 오른쪽 자식은 \[(2\*i)+2] 번
1. i번 노드의 부모는 \[(i-1)/2] 번

### 우선순위 큐

들어간 데이터 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 큐이다.  
우선순위는 로직에따라 최소값이 될수도있고 최대값이 될수도있다.
우선순위 큐를 구현하는 방법은 여러가지이지만 그중 힙트리를 이용하여 만든 우선순위큐가 가장 효율적이다.
