# Object Pooling

## 오브젝트 풀링 기법

오브젝트 풀링이란?  
유니티 프로그래밍에서 객체를 생성하고 지우는 과정에서 생기는 메모리 단편화 문제나 또는 Instantiate와 Destory 같은 비용이 큰 함수가 반복해서 사용 될 때 성능 저하 문제들을 해결하기 위해 오브젝트 풀링 기법을 사용한다.

단점으로는 내가 미리 생성한 객체는 필요가 없을 때에도 메모리내에 존재하기 때문에 적당한 테스트를 통해 미리 생성될 객체의 수치를 찾아야 한다.

### 메모리 단편화 문제

메모리 단편화에는 외부 메모리 단편화와 내부 메모리 단편화가 있는데, 현 상황에서는 외부 메모리 단편화가 발생한다.

외부 메모리 단편화란, 메모리에 빈 공간이 충분함에도 불구하고 빈 공간들이 따로 떨어져 있어서, 새로운 오브젝트를 생성하지 못하는 현상을 말한다.

1. 유니티에서 Instantiate 함수를 이용해서 오브젝트 1~ 오브젝트 4 에게 메모리 공간을 할당해주었다.

| 빈 공간 | 오브젝트 1 (1) | 오브젝트 2 (1) | 오브젝트 3 (3) | 오브젝트 4 (1) | 빈 공간 |
| :-----: | :------------: | :------------: | :------------: | :------------: | :-----: |

2. Destroy 함수로 오브젝트 2를 없앴다.

| 빈 공간 | 오브젝트 1 (1) | 빈 공간 | 오브젝트 3 (3) | 오브젝트 4 (1) | 빈 공간 |
| :-----: | :------------: | :-----: | :------------: | :------------: | :-----: |

3. 이때 크기가 3인 오브젝트 5 (3)를 Instantiate함수로 생성하려고 했는데, 오브젝트 5에게 할당해줄 메모리 공간이 없다. 이때 빈 공간 3개를 합치면 오브젝트 5에게 할당해줄 연속된 공간이 충분하겠지만, 빈 공간이 따로 떨어져 있다보니 오브젝트 5 생성에 문제가 생긴 것이다.

이렇게 Instantiate와 Destroy 함수를 계속 사용하다 보면 빈 공간이 우후죽순 생기게 되고, 메모리가 효율적으로 관리되지 못한다.
이런 상황을 외부 메모리 단편화라고 한다.

### 유니티에서는 메모리 단편화를 해결하지 못한다.

보통의 C#에서는 가비지컬렉터(GC)가 메모리 단편화를 Compaction 해서 해결한다.

| 오브젝트 1 (1) | 오브젝트 3 (3) | 오브젝트 4 (1) | 빈 공간 | 빈 공간 | 빈 공간 |
| :------------: | :------------: | :------------: | :-----: | :-----: | :-----: |

위 3번의 메모리 단편화 상황에서 Compaction을 사용하여 문제를 해결할 수 있었을 것이다.

하지만, 유니티의 GC는 Compaction 기능을 지원하지 않는다.

[Unity/Documentation/version 2021.1](https://docs.unity3d.com/kr/2021.1/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)

> (본문 내용 발췌 )여기서 중요한 사실은 Unity 가비지 컬렉션은 [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) 알고리즘을 사용하며, 이는 비세대 기반이고 비압축화 되어있다는 것 입니다.

결과적으로 유니티에서 오브젝트 풀링은 유니티 메모리 최적화의 핵심이다.
